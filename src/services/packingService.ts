import { PackageType, PackingInput, PackingResult, PlacedItem } from '../types';

// --- CORE PACKING ENGINE ---
// This calculates a single layout based on a specific list order
const runSimulation = (container: any, itemsToPack: { type: PackageType, id: string, vol: number }[]) => {
    // Clone the list so we don't mess up the original order for other strategies
    const queue = [...itemsToPack];
    
    const placedItems: PlacedItem[] = [];
    
    // Coordinate system: x=Width, y=Height, z=Depth
    // Anchors are "candidate spots" where a box corner could go.
    // We sort them to prefer: Back (Z) -> Bottom (Y) -> Left (X)
    let anchors: {x: number, y: number, z: number}[] = [{ x: 0, y: 0, z: 0 }];
    
    const tryPlaceItem = (anchor: {x: number, y: number, z: number}, type: PackageType): PlacedItem | null => {
        const { length: L, width: W, height: H } = type.dimensions;
        
        // Define all 6 possible orientations
        // l = dimension along Z (depth)
        // w = dimension along X (width)
        // h = dimension along Y (height)
        const allOrientations = [
            { l: L, w: W, h: H }, // Standard
            { l: W, w: L, h: H }, // Flat Rotated
            { l: L, w: H, h: W }, // On Side
            { l: W, w: H, h: L }, // On Side Rotated
            { l: H, w: W, h: L }, // Upright
            { l: H, w: L, h: W }, // Upright Rotated
        ];

        // --- CONSTRAINT LOGIC ---
        // If keepUpright is true, we ONLY allow orientations where the resulting height (h) 
        // matches the package's original height (H).
        const allowedOrientations = type.keepUpright 
            ? allOrientations.filter(o => Math.abs(o.h - H) < 0.1) 
            : allOrientations;

        for (const orient of allowedOrientations) {
             // 1. Container Bounds Check
             if (anchor.x + orient.w > container.width) continue;
             if (anchor.y + orient.h > container.height) continue;
             if (anchor.z + orient.l > container.length) continue;

             // 2. Collision Check against already placed items
             let overlap = false;
             for (const p of placedItems) {
                if (
                    anchor.x < p.x + p.width && anchor.x + orient.w > p.x &&
                    anchor.y < p.y + p.height && anchor.y + orient.h > p.y &&
                    anchor.z < p.z + p.length && anchor.z + orient.l > p.z
                ) {
                    overlap = true;
                    break;
                }
             }

             if (!overlap) {
                 return {
                     x: anchor.x,
                     y: anchor.y,
                     z: anchor.z,
                     width: orient.w,
                     height: orient.h,
                     length: orient.l,
                     packageId: type.id,
                     color: type.color,
                     label: type.name
                 };
             }
        }
        return null;
    };

    // The Loop: Keep going until we run out of anchors or items
    // Safety break to prevent browser freezing on massive lists
    let safety = 0;
    while (anchors.length > 0 && queue.length > 0 && safety < 5000) {
        safety++;
        
        // Critical: Sort anchors to ensure we fill Back-to-Front (Z), Bottom-to-Top (Y)
        anchors.sort((a, b) => {
            if (Math.abs(a.z - b.z) > 0.1) return a.z - b.z; // Deepest first
            if (Math.abs(a.y - b.y) > 0.1) return a.y - b.y; // Lowest first
            return a.x - b.x; // Leftmost first
        });

        const currentAnchor = anchors[0];
        let placed: PlacedItem | null = null;
        let placedIndex = -1;

        // Try to find the FIRST item in our queue that fits this anchor
        // (The intelligence comes from how we SORTED the queue before calling this function)
        for (let i = 0; i < queue.length; i++) {
            placed = tryPlaceItem(currentAnchor, queue[i].type);
            if (placed) {
                placedIndex = i;
                break; // Found one!
            }
        }

        if (placed) {
            placedItems.push(placed);
            queue.splice(placedIndex, 1); // Remove from to-do list

            // Consume the anchor we just used
            anchors.shift();

            // Add new candidate anchors generated by this box
            // 1. On Top
            anchors.push({ x: placed.x, y: placed.y + placed.height, z: placed.z });
            // 2. To Right
            anchors.push({ x: placed.x + placed.width, y: placed.y, z: placed.z });
            // 3. In Front
            anchors.push({ x: placed.x, y: placed.y, z: placed.z + placed.length });
        } else {
            // Nothing fits here (too small gap). Discard anchor.
            anchors.shift();
        }
    }

    return placedItems;
};


// --- MAIN CALCULATOR ---
export const calculatePacking = (input: PackingInput): PackingResult => {
  const container = input.container;
  
  // 1. Expand Inputs into a flat list of items
  // We treat "infinite" items (quantity=0) as "just a lot of them" (e.g. 200) 
  let allItems: { type: PackageType, id: string, vol: number, maxDim: number, area: number }[] = [];

  input.packages.forEach(pkg => {
    const count = (!pkg.quantity || pkg.quantity === 0) ? 200 : pkg.quantity; 
    const vol = pkg.dimensions.length * pkg.dimensions.width * pkg.dimensions.height;
    const area = pkg.dimensions.width * pkg.dimensions.height; // Face area
    const maxDim = Math.max(pkg.dimensions.length, pkg.dimensions.width, pkg.dimensions.height);

    for (let i = 0; i < count; i++) {
      allItems.push({
        type: pkg,
        id: `${pkg.id}-${i}`,
        vol,
        maxDim,
        area
      });
    }
  });

  // Limit total items to prevent browser crash if user types 100,000
  if (allItems.length > 2000) allItems = allItems.slice(0, 2000);

  // --- THE "META" STRATEGY: COMPETITIVE SIMULATION ---
  // We will run the packing engine multiple times with different sorting strategies
  // and pick the one that results in the highest volume utilization.

  const strategies = [
      // 1. Volume Descending (Classic Greedy)
      (list: typeof allItems) => [...list].sort((a, b) => b.vol - a.vol),
      
      // 2. Max Dimension Descending (Good for long poles/pipes)
      (list: typeof allItems) => [...list].sort((a, b) => b.maxDim - a.maxDim),
      
      // 3. Footprint/Area Descending (Good for pallets)
      (list: typeof allItems) => [...list].sort((a, b) => b.area - a.area),
      
      // 4. Width Descending (Tries to fill rows)
      (list: typeof allItems) => [...list].sort((a, b) => b.type.dimensions.width - a.type.dimensions.width),
  ];

  // Add 5 Random Shuffles (Monte Carlo) to break out of local optimums
  // "Random" often beats logic in packing irregular shapes.
  for(let i=0; i<5; i++) {
      strategies.push((list) => [...list].sort(() => Math.random() - 0.5));
  }

  let bestResult: PlacedItem[] = [];
  let maxVolumeFound = -1;

  // Run the competition
  strategies.forEach((strategy) => {
      const sortedList = strategy(allItems);
      const result = runSimulation(container, sortedList);
      
      const currentVol = result.reduce((acc, item) => acc + (item.width * item.height * item.length), 0);
      
      if (currentVol > maxVolumeFound) {
          maxVolumeFound = currentVol;
          bestResult = result;
      }
  });

  // --- FINALIZE ---
  const totalContainerVol = container.length * container.width * container.height;
  const usedVol = bestResult.reduce((acc, item) => acc + (item.width * item.height * item.length), 0);
  
  // Calculate Layers for Visualization
  // We round Z to 1 decimal to group items that are essentially on the same "face"
  const uniqueZ = Array.from(new Set(bestResult.map(p => parseFloat(p.z.toFixed(1))))).sort((a, b) => a - b);

  return {
    containerDimensions: container,
    placedItems: bestResult,
    unplacedItems: [], 
    volumeUtilization: totalContainerVol > 0 ? (usedVol / totalContainerVol) * 100 : 0,
    totalItemsPacked: bestResult.length,
    layers: uniqueZ
  };
};